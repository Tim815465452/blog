<?xml-stylesheet type="text/xsl" href="/codes/template.xsl"?>
<page>
	<title>NOIp 2004 PJT2</title>
	<html>
		<center>
			<h2>NOIp 2004 PJT2</h2>
			<var>2016-12-23 13:02 by zsz12251665</var>
		</center>
		<h3>Problem</h3>
		<section>
			<a target="_blank" href="https://www.luogu.org/problem/show?pid=1086">Luogu</a>
			<br/>
			<a target="_blank" href="https://www.vijos.org/p/1120">Vijos</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>The algorithm of this problem is like simulation. First of all, we'll find the tree with most peanuts,  have the shortest way for a round trip. Then we'll check whether it is under the time constraint. If it isn't,just end the loop and print the answer, or pick the peanuts and find the new tree with most peanuts. And add it into the route, the length fo the route is the Manhattan distance between the last tree and the new one. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<div class="codebox">
				var<br/>
				&#160;&#160;&#160;&#160;p:array[1..20,1..20]of integer;<br/>
				&#160;&#160;&#160;&#160;i,j,k,n,m,sum,max:integer;<br/>
				&#160;&#160;&#160;&#160;lasti,lastj:integer;<strong>//The coordinate of the last visited tree</strong><br/>
				&#160;&#160;&#160;&#160;maxi,maxj:integer;<strong>//The coordinate of the tree with most peanuts</strong><br/>
				begin<br/>
				&#160;&#160;&#160;&#160;sum:=0;<br/>
				&#160;&#160;&#160;&#160;max:=-maxint;<br/>
				&#160;&#160;&#160;&#160;read(n,m,k);<br/>
				&#160;&#160;&#160;&#160;for i:=1 to n do<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for j:=1 to m do<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;begin<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;read(p[i,j]);<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if p[i,j]&gt;max then<strong>//Find the tree with most peanuts</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;begin<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;max:=p[i,j];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxi:=i;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxj:=j;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br/>
				&#160;&#160;&#160;&#160;lasti:=0;<strong>//Decide the start point</strong><br/>
				&#160;&#160;&#160;&#160;lastj:=maxj;<br/>
				&#160;&#160;&#160;&#160;k:=k-abs(maxj-lastj)-1;<strong>//Calculate the extra time</strong><br/>
				&#160;&#160;&#160;&#160;if maxi&gt;lasti then<strong>//If max point isn't on the way back</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k:=k-(maxi-lasti)*2;<br/>
				&#160;&#160;&#160;&#160;while k&gt;=0 do<strong>//Check if it's in the time constraint</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;begin<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum:=sum+max;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p[maxi,maxj]:=0;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;max:=-maxint;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lasti:=maxi;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lastj:=maxj;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for i:=1 to n do<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for j:=1 to m do<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if p[i,j]&gt;max then<strong>//Find the tree with most peanuts</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;begin<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;max:=p[i,j];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxi:=i;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxj:=j;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k:=k-abs(maxj-lastj)-1;<strong>//Calculate the extra time</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if maxi&gt;lasti then<strong>//If max point isn't on the way back</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k:=k-(maxi-lasti)*2;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br/>
				&#160;&#160;&#160;&#160;writeln(sum);<br/>
				end.<br/>
			</div>
			<p>C++</p>
			<div class="codebox">
				#include&lt;cstdio&gt;<br/>
				int p[20][20],k,n,m,sum=0,max=-65535;<br/>
				int lasti,lastj;<strong>//The coordinate of the last visited tree</strong><br/>
				int maxi,maxj;<strong>//The coordinate of the tree with most peanuts</strong><br/>
				int abs(int n)<br/>
				{<br/>
				&#160;&#160;&#160;&#160;if(n&gt;0)<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return n;<br/>
				&#160;&#160;&#160;&#160;else<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return -n;<br/>
				}<br/>
				int main()<br/>
				{<br/>
				&#160;&#160;&#160;&#160;scanf("%d%d%d",&amp;n,&amp;m,&amp;k);<br/>
				&#160;&#160;&#160;&#160;for(int i=0;i&lt;n;i++)<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(int j=0;j&lt;m;j++)<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;scanf("%d",&amp;p[i][j]);<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(p[i][j]>max)<strong>//Find the tree with most peanuts</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;max=p[i][j];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxi=i;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxj=j;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
				&#160;&#160;&#160;&#160;lasti=-1;<strong>//Decide the start point</strong><br/>
				&#160;&#160;&#160;&#160;lastj=maxj;<br/>
				&#160;&#160;&#160;&#160;k-=abs(maxj-lastj)+1;<strong>//Calculate the extra time</strong><br/>
				&#160;&#160;&#160;&#160;if(maxi&gt;lasti)<strong>//If max point isn't on the way back</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k-=(maxi-lasti)*2;<br/>
				&#160;&#160;&#160;&#160;while(k&gt;=0)<br/>
				&#160;&#160;&#160;&#160;{<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum+=max;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p[maxi][maxj]=0;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;max=-65535;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lasti=maxi;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lastj=maxj;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(int i=0;i&lt;n;i++)<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(int j=0;j&lt;m;j++)<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(p[i][j]>max)<strong>//Find the tree with most peanuts</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;max=p[i][j];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxi=i;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;maxj=j;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k-=abs(maxj-lastj)+1;<strong>//Calculate the extra time</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(maxi&gt;lasti)<strong>//If max point isn't on the way back</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k-=(maxi-lasti)*2;<br/>
				&#160;&#160;&#160;&#160;}<br/>
				&#160;&#160;&#160;&#160;printf("%d",sum);<br/>
				&#160;&#160;&#160;&#160;return 0;<br/>
				}<br/>
			</div>
		</section>
	</html>
</page>
