<?xml-stylesheet type="text/xsl" href="/codes/template.xsl"?>
<page>
	<title>NOIp 2004 TGT2</title>
	<html>
		<center>
			<h2>NOIp 2004 TGT2</h2>
			<var>2017-04-25 20:12 by zsz12251665</var>
		</center>
		<h3>Problem</h3>
		<section>
			<a target="_blank" href="https://www.luogu.org/problem/show?pid=1090">Luogu</a>
			<br/>
			<a target="_blank" href="https://www.vijos.org/p/1097">Vijos</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>Well, let's define that the bunches of fruits are fruit[1] to fruit[n]. And for very i in [1,n-1], fruit[i] is smaller than fruit[i+1]. When we need to combine two bunches of fruits, choose fruit[1] and fruit[2] can keep the least cost since they are the smallest ones. And then we add the new bunch which is fruit[1]+fruit[2] back to the fruit array. Now we have n-1 bunches now. Repeat these steps, we can finally have a single bunch with least cost. </p>
			<p>What's important is that we can use a heap to keep the fruit array. The heap is a data structure with an O(lg(n)) insert and O(lg(n)) extract. With the heap to keep the fruit array, we can reduce the time complexity to O(n lg(n)), which is fast enough to solve the problem. </p>
			<p>While building up the heap, I found a way to make fewer mistakes when extracting. That is fill the null part with maxlongint. That means if a point has no child, it has a child or two children with maxlongint. That can be very helpful because I don't need to judge if the point has child or not by the size of the heap. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Pascal</p>
			<div class="codebox">
				var<br/>
				&#160;&#160;&#160;&#160;fruit:array[1..20000]of longint;<strong>//To avoid overlimit, I made the fruit array twice larger</strong><br/>
				&#160;&#160;&#160;&#160;n,size,i:integer;<br/>
				&#160;&#160;&#160;&#160;ans,tmp:longint;<br/>
				procedure insert(a:longint);<strong>//The proceudure to insert a number into the fruit array</strong><br/>
				var<br/>
				&#160;&#160;&#160;&#160;i:integer;<br/>
				&#160;&#160;&#160;&#160;tmp:longint;<br/>
				begin<br/>
				&#160;&#160;&#160;&#160;inc(size);<br/>
				&#160;&#160;&#160;&#160;fruit[size]:=a;<br/>
				&#160;&#160;&#160;&#160;i:=size;<strong>//Maintain the heap</strong><br/>
				&#160;&#160;&#160;&#160;while (i&gt;1)and(fruit[i]&lt;fruit[i div 2]) do<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;begin<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tmp:=fruit[i];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fruit[i]:=fruit[i div 2];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fruit[i div 2]:=tmp;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i:=i div 2;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br/>
				end;<br/>
				function extract:longint;<strong>//The proceudure to extract the top from the fruit array</strong><br/>
				var<br/>
				&#160;&#160;&#160;&#160;i:integer;<br/>
				&#160;&#160;&#160;&#160;tmp:longint;<br/>
				begin<br/>
				&#160;&#160;&#160;&#160;extract:=fruit[1];<br/>
				&#160;&#160;&#160;&#160;fruit[1]:=fruit[size];<br/>
				&#160;&#160;&#160;&#160;fruit[size]:=maxlongint;<strong>//Fill the null part with maxlongint</strong><br/>
				&#160;&#160;&#160;&#160;dec(size);<br/>
				&#160;&#160;&#160;&#160;i:=1;<strong>//Maintain the heap</strong><br/>
				&#160;&#160;&#160;&#160;while (fruit[i*2]&lt;fruit[i])or(fruit[i*2+1]&lt;fruit[i]) do<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;begin<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if fruit[i*2]&lt;fruit[i*2+1] then<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i:=i*2<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i:=i*2+1;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tmp:=fruit[i];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fruit[i]:=fruit[i div 2];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fruit[i div 2]:=tmp;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br/>
				end;<br/>
				begin<br/>
				&#160;&#160;&#160;&#160;size:=0;<br/>
				&#160;&#160;&#160;&#160;ans:=0;<br/>
				&#160;&#160;&#160;&#160;read(n);<br/>
				&#160;&#160;&#160;&#160;for i:=1 to 2*n do<strong>//Fill the array with maxlongint</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fruit[i]:=maxlongint;<br/>
				&#160;&#160;&#160;&#160;for i:=1 to n do<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;begin<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;read(tmp);<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;insert(tmp);<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br/>
				&#160;&#160;&#160;&#160;for i:=1 to n-1 do<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;begin<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tmp:=extract+extract;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ans:=ans+tmp;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;insert(tmp);<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br/>
				&#160;&#160;&#160;&#160;write(ans);<br/>
				end.<br/>
			</div>
			<p>C++</p>
			<div class="codebox">
				#include&lt;cstdio&gt;<br/>
				long fruit[20000];<strong>//To avoid overlimit, I made the fruit array twice larger</strong><br/>
				int size=0;<br/>
				void insert(long a)<strong>//The proceudure to insert a number into the fruit array</strong><br/>
				{<br/>
				&#160;&#160;&#160;&#160;size++;<br/>
				&#160;&#160;&#160;&#160;fruit[size]=a;<br/>
				&#160;&#160;&#160;&#160;int i=size;<strong>//Maintain the heap</strong><br/>
				&#160;&#160;&#160;&#160;while((i&gt;1)&amp;&amp;(fruit[i]&lt;fruit[i/2]))<br/>
				&#160;&#160;&#160;&#160;{<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;long tmp=fruit[i];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fruit[i]=fruit[i/2];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fruit[i/2]=tmp;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i/=2;<br/>
				&#160;&#160;&#160;&#160;}<br/>
				}<br/>
				long extract()<strong>//The proceudure to extract the top from the fruit array</strong><br/>
				{<br/>
				&#160;&#160;&#160;&#160;long ans=fruit[1];<strong>//C++ couldn't use the use the name of function to keep the feedback, so I have to use another longint to keep it</strong><br/>
				&#160;&#160;&#160;&#160;fruit[1]=fruit[size];<br/>
				&#160;&#160;&#160;&#160;fruit[size]=2147483647;<strong>//Fill the null part with maxlongint</strong><br/>
				&#160;&#160;&#160;&#160;size--;<br/>
				&#160;&#160;&#160;&#160;int i=1;<strong>//Maintain the heap</strong><br/>
				&#160;&#160;&#160;&#160;while((fruit[i*2]&lt;fruit[i])||(fruit[i*2+1]&lt;fruit[i]))<br/>
				&#160;&#160;&#160;&#160;{<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(fruit[i*2]&lt;fruit[i*2+1])<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i*=2;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i=i*2+1;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;long tmp=fruit[i];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fruit[i]=fruit[i/2];<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fruit[i/2]=tmp;<br/>
				&#160;&#160;&#160;&#160;}<br/>
				&#160;&#160;&#160;&#160;return ans;<br/>
				}<br/>
				int main()<br/>
				{<br/>
				&#160;&#160;&#160;&#160;long ans=0,tmp;<br/>
				&#160;&#160;&#160;&#160;int n;<br/>
				&#160;&#160;&#160;&#160;scanf("%d",&amp;n);<br/>
				&#160;&#160;&#160;&#160;for(int i=1;i&lt;=2*n;i++)<strong>//Fill the array with maxlongint</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fruit[i]=2147483647;<br/>
				&#160;&#160;&#160;&#160;for(int i=0;i&lt;n;i++)<br/>
				&#160;&#160;&#160;&#160;{<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;scanf("%ld",&amp;tmp);<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;insert(tmp);<br/>
				&#160;&#160;&#160;&#160;}<br/>
				&#160;&#160;&#160;&#160;for(int i=1;i&lt;n;i++)<br/>
				&#160;&#160;&#160;&#160;{<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tmp=extract()+extract();<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ans+=tmp;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;insert(tmp);<br/>
				&#160;&#160;&#160;&#160;}<br/>
				&#160;&#160;&#160;&#160;printf("%ld",ans);<br/>
				&#160;&#160;&#160;&#160;return 0;<br/>
				}<br/>
			</div>
		</section>
	</html>
</page>
