<?xml-stylesheet type="text/xsl" href="/codes/template.xsl"?>
<page>
	<title>BZOJ 4300</title>
	<html>
		<center>
			<h2>BZOJ 4300</h2>
			<var>2016-12-21 20:18 by zsz12251665</var>
		</center>
		<h3>Problem</h3>
		<section>
			<a target="_blank" href="https://vjudge.net/problem/HYSBZ-4300">vjudge</a>
			<br/>
			<a target="_blank" href="http://www.lydsy.com/JudgeOnline/problem.php?id=4300">BZOJ</a>
		</section>
		<h3>Solution</h3>
		<section>
			<p>When I read the problem the first time, I thought out a way like solving the longest increasing subsequence problem, which means I just need an array to keep the longest subsequence until this integer. The code is given as Solution 1 in the code part. </p>
			<p>However, when I submitted it to the judge, the answer was TLE(Time Limit Exceed) because the time complexity is O(n^2). Later, I got another algorithm whose time complexity is O(n lg(ai)). It just needs a dp(dynamic programming) array. dp[i] keeps the length of the longest subsequence whose last integer's i-th digit is not 0 in binary. So after read in each integer in sequence, I can update the dp array in an O(lg(ai)) algorithm. And that is Solution 2, which is accepted. </p>
		</section>
		<h3>Code</h3>
		<section>
			<p>Solution 1 C++</p>
			<div class="codebox">
				#include&lt;cstdio&gt;<br/>
				#define MAXN 100000<br/>
				long a[MAXN],len[MAXN];<br/>
				int main()<br/>
				{<br/>
				&#160;&#160;&#160;&#160;long n,ans=0;<br/>
				&#160;&#160;&#160;&#160;scanf("%ld",&amp;n);<br/>
				&#160;&#160;&#160;&#160;for(long i=0;i&lt;n;i++)<br/>
				&#160;&#160;&#160;&#160;{<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;scanf("%d",&amp;a[i]);<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;len[i]=1;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(long j=0;j&lt;i;j++)<strong>//Update the array len</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(((a[j]&amp;a[i])!=0)&amp;&amp;(len[j]+1&gt;len[i]))<strong>//Judge if a[i] can be added after a[j] and if it's the best solution</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;len[i]=len[j]+1;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(ans&lt;len[i])<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ans=len[i];<br/>
				&#160;&#160;&#160;&#160;}<br/>
				&#160;&#160;&#160;&#160;printf("%ld",ans);<br/>
				&#160;&#160;&#160;&#160;return 0;<br/>
				}<br/>
			</div>
			<p>Solution 2 C++</p>
			<div class="codebox">
				#include&lt;cstdio&gt;<br/>
				#define MAXN 100000<br/>
				long a[MAXN],dp[32];<br/>
				long max(long a,long b)<br/>
				{<br/>
				&#160;&#160;&#160;&#160;if(a&gt;b)<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return a;<br/>
				&#160;&#160;&#160;&#160;else<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return b;<br/>
				}<br/>
				int main()<br/>
				{<br/>
				&#160;&#160;&#160;&#160;long n,ans=0;<br/>
				&#160;&#160;&#160;&#160;scanf("%ld",&amp;n);<br/>
				&#160;&#160;&#160;&#160;for(long i=0;i&lt;n;i++)<br/>
				&#160;&#160;&#160;&#160;{<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;scanf("%ld",&amp;a[i]);<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;long now=0;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(long j=0;j&lt;32;j++)<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if((a[i]&amp;(1&lt;&lt;j))!=0)<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;now=max(dp[j],now);<strong>//Find the length of the longest subsequence that can be added by a[i]</strong><br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;now++;<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(long j=0;j&lt;32;j++)<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if((a[i]&amp;(1&lt;&lt;j))!=0)<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dp[j]=max(dp[j],now);<strong>//Update the dp array</strong><br/>
				&#160;&#160;&#160;&#160;}<br/>
				&#160;&#160;&#160;&#160;for(long j=0;j&lt;32;j++)<br/>
				&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ans=max(dp[j],ans);<br/>
				&#160;&#160;&#160;&#160;printf("%ld",ans);<br/>
				&#160;&#160;&#160;&#160;return 0;<br/>
				}<br/>
			</div>
		</section>
	</html>
</page>
